### CSRF（跨站请求伪造，cross-site request forgery）

**概念：**

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击者发送跨站请求，攻击网站利用受害者在被攻击网站注册所获取到的凭证，向被攻击网站发送某个操作请求，绕过后台的用户验证，达到冒充用户对被攻击网站进行某项操作的目的。

**原理**

![](C:\file_xy\daily_notes\images\xss\x1.png)

从上图我们可以知道，想要完成一次CSRF攻击必须满足俩个条件：

- 用户必须登录受信任网站A，并生成cookie。（如果用户没有登录受信任的网站A，那么网站B在诱导用户户对网站A进行操作时，就会提示需要登录）
- 用户在不退出登录的状态访问危险网站B（攻击者）

#### **如何防御？**

**验证HTTP Referer字段**

根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。也就是说，服务器会验证客户端的请求来源，判断是不是本网站的请求，是则相应否则不响应。

当然这种方式也存在隐患，

- 对于某些浏览器，已经存在一些方法可以篡改Referer的值。
- 用户可以自己设置浏览器在发送请求的不携带referer字段。

**Token验证**

用户在打开页面的时候，服务器需要给这个用户生成一个token，该token通过加密算法对数据进行加密。

防护策略三步骤：

1. 将CSRF Token输出到页面中
2. 页面提交表单的时候携带Token
3. 服务器验证Token是否正确

另外一种使用方式：隐藏令牌，将Token隐藏在HTTP的HEAD头中。

**双重Cookie验证**

当用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串；

在前端向后端发起请求时，取出Cookie，并添加到请求URL的参数中；

服务端验证Cookie是否与请求携带的参数Cookie一致，是则响应，否则拒绝这个请求

优点：

- 无需使用session，适用面更广，实施更容易
- 相对于Token，实施成本更低，可以在前后端统一拦截检验，而不需要一个个接口和页面去添加

缺点：

- Cookie增加了额外的字段
- 如果有其他漏洞（比如XSS），攻击者可以注入Cookie，那么该防御方式失效

### XSS（跨域脚本攻击，Cross Site Scripting）

#### **什么是XSS？**

XSS是一种代码注入攻击，攻击者通过向目标网站注入恶意脚本，使之在用户的浏览器上恶意运行，利用这些恶意脚本，攻击者可以获取到用户的敏感信息，比如：Cookie，SessionID等，进而危害数据安全。

**XSS的本质：恶意代码未经过滤，与网页的正常代码混在一起，浏览器无法分辨哪些代码是恶意脚本，导致恶意脚本被运行**

#### **XSS分类**

**存储型XSS**

攻击步骤：

1. 攻击者将恶意脚本提交到目标网站的数据库中
2. 用户打开目标网站时，网站服务器将恶意代码从数据库取出，拼接在HTML返回给用户
3. 用户浏览器收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送给攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。

**反射性XSS**

1. 攻击者构造特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL，目标网站服务器将URL中的恶意代码取出，拼接在HTML中返回给用户
3. 用户浏览器收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送给攻击者网站，或者冒充用户的行为，调用目标网站的接口执行攻击者指定的操作

**存储型XSS和反射性XSS的区别在于：存储型XSS的恶意代码存储在数据库中，反射型XSS的恶意代码存储在URL里**

**DOM型XSS**

攻击者构造特殊的URL

用户点击带有恶意代码的URL

用户浏览器收到响应后解析执行，前端JavaScript将恶意代码从URL中取出并执行

恶意代码窃取用户数据并发送给攻击者网站，或者冒充用户的行为，调用目标网站的接口执行攻击者指定的操作。

**DOM型XSS和前面俩种类型的区别在于：DOM型XSS攻击中，取出和执行恶意代码都是由浏览器端完成，是前端JavaScript自身的安全漏洞，而前面俩种XSS属于服务端的安全漏洞。**

#### 预防XSS

